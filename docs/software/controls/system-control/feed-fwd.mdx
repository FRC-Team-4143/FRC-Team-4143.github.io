---
title: Feed Forward Control
description: PID Control for systems with the need for precise control.
hide_table_of_contents: false
sidebar_position: 2
---

# Feed Forward Control
Feed Forward control is a type of open loop control that uses a mathematical model of the system to predict the required input to achieve a desired output. This is the primary open loop control concept, because there are not many other options without requiring feedback.
```mermaid
stateDiagram-v2
    direction LR

    Setpoint --> Computer
    Computer --> Motor
    Motor --> Output
```
Unlike closed loop control, which relies on feedback from sensors to adjust the input, feed forward control anticipates the system's behavior and applies the necessary input directly. 
Sometimes that model can be a simple constant other times it can be a more complex equation.
That model can only use the desired setpoint for its calculations since open loop control types don't have feedback.
This page should serve as an introduction to feed forward control and how it can be used in FRC applications, but you can read more on WPILib's Feed Forward page [here](https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/introduction-to-feedforward.html).

:::warning[It Doesn't have to be this Complicated]
For most of our applications using feed forward control, it's just a simple % of the max output. 
Typically we won't even refer to this method as feed forward control, we will just call it open loop control or percent output control.
See the [Just Getting the Darn Thing to Move](#just-getting-the-darn-thing-to-move) section below for more info.
:::
---

## Using a Mathematical Model
However there are some applications where a more sophisticated feed forward model is required. In these cases, we may need to take into account additional factors such as the system's dynamics or external disturbances. Luckily, there is an equation we can use to help us calculate the feed forward output.
$$
V = K_s \cdot sgn(\dot{d}) + K_v \cdot \dot{d} + K_a \cdot \ddot{d}
$$
Where $V$ is voltage to be applied to the motor, ${d}$ is position, $\dot{d}$ is the desired velocity, and $\ddot{d}$ is the desired acceleration.
Don't worry this equation is much simpler than it looks. The variables are as follows:
- $K_s$: The static gain, which determines the initial response of the system to a change in the desired output. This is typically the voltage needed to overcome friction and other static forces or in other words the minimum power needed to get the system moving. This is a constant value throught out motor operation since we assume friction is constant and presnet during acceleration and all velocities.
- $K_v$: The velocity gain, which accounts for the rate of change of the desired output. This is typically the voltage needed to maintain a certain velocity. This is a constant value throughout motor operation since we assume drag and other forces that resist motion are constant during all velocities. The relationship between speed and voltage is approximately linear for all FRC legal components.
- $K_a$: The acceleration gain, which considers the acceleration of the desired output. This is typically the voltage needed to achieve a certain acceleration. This is a constant value throughout motor operation since we assume inertia and other forces that resist changes in motion are constant during all velocities.
Let's break down more of the equation so it's simpler to understand. The equation can be thought of as a sum of three components: the static component, the velocity component, and the acceleration component. Each component contributes to the overall output voltage based on the current state of the system.

### Static Component
Our static component is multiplied by the sign of the desired velocity. This means that if we want to move forward we will apply a positive voltage and if we want to move backwards we will apply a negative voltage. This is important because it ensures that we are always applying the correct direction of force to the system.
$$
K_s \cdot sgn(\dot{d})
$$

### Velocity Component
Our velocity component is simply the desired velocity multiplied by the velocity gain. This means that the faster we want to move, the more voltage we will apply. This is important because it allows us to control the speed of the system directly.
$$
K_v \cdot \dot{d}
$$

### Acceleration Component
Our acceleration component is the desired acceleration multiplied by the acceleration gain. This means that the more we want to accelerate, the more voltage we will apply. This is important because it allows us to control the acceleration of the system directly.
$$
K_a \cdot \ddot{d}
$$

---

## Variants of the Feed Forward Equation
There are many variants of this equation that can be used depending on the specific application. We use a few of them in FRC based on what system our robot has for that given year.
These are most common to account for gravity. The equation doesn't always refer to speed, it position and angle can be used as well depending on the system.

### Elevator Feed Forward
Unlike some of the other systems, the elevator system has to account for the weight of the elevator itself. This means that we need to add a term to our feed forward equation that accounts for the gravitational force acting on the elevator. This is typically done by adding a term $K_g$ component to represent the voltage needed to hold the elevator in place against gravity.
$$
V = K_g + K_s \cdot sgn(\dot{d}) + K_v \cdot \dot{d} + K_a \cdot \ddot{d}
$$

### Arm Feed Forward
Arms have the same problem as elevators, but it's a little more complex since the angle of the arm changes the amount of force needed to hold it in place. This means that we need to add a term to our feed forward equation that accounts for the gravitational force acting on the arm based on its angle. This is typically done by adding a term $K_g \cdot cos(\theta)$ component to represent the voltage needed to hold the arm in place against gravity.
$$
V = K_g \cdot cos(\theta) + K_s \cdot sgn(\dot{\theta}) + K_v \cdot \dot{\theta} + K_a \cdot \ddot{\theta}
$$
Where $\theta$ is the angle of the arm, $\dot{\theta}$ is the angular velocity, and $\ddot{\theta}$ is the angular acceleration.

---

## Tuning a Feed Forward Controller
To use the feed forward equation effectively, we need to determine the values of the constants $K_s$, $K_v$, $K_a$, and $K_g$ for our specific system. This can be done through a combination of theoretical calculations and empirical testing. If possible, the Design team may be able to provide some of these values based on the mechanical design of the system. Otherwise, we can perform tests on the actual robot to determine these values.

:::danger Tuning Risks
Be very careful when tuning a Feed Forward controller on a live system. Aggressive tuning can lead to instability, oscillations, or even damage to the system. Always start with conservative values and gradually adjust them while monitoring the system's response. If you notice any erratic behavior, immediately stop and reassess your tuning approach.
:::

- **Ks**: Slowly increase the voltage to the motor until the mechanism just starts to move. The voltage at which it starts to move is your static gain (Ks).
- **Kv**: Run the mechanism at a constant speed and measure the voltage required to maintain that speed. Divide the voltage by the speed to get your velocity gain (Kv).
- **Ka**: Apply a known acceleration to the mechanism and measure the voltage required to achieve that acceleration. Divide the voltage by the acceleration to get your acceleration gain (Ka).
- **Kg**: For elevators and arms, measure the voltage required to hold the mechanism in place against gravity. This voltage is your gravity gain (Kg).

---

## Just Getting the Darn Thing to Move!
Like stated in above examples and explanations, many times you don't need to use the full equation to get the desired results.
If we just want to get a mechanism to move at a approximate speed we can just kinda guess or adjust the output percentage until it works well enough.
For example, if we want an intake to spin fast enough to pick up a game piece, we can just set the motor to 60% output and see if it works and adjust from there.
```java
intakeMotor.set(0.6);
```
This will just set the motor driving voltage to 60% of the max voltage and the motor will spin at whatever speed that results in.
:::info
If we actually care what speed the intake spins at we could use a velocity feed forward to get more precise control.
:::